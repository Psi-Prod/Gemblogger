---
title: "Mehari 3.0"
date: 2023-07-25
authors:
  - Tim
description: Nouvelle mise-Ã -jour
tags:
- devlog
- ocaml
- mehari
---

Mehari 0.3 est sorti et aujourd'hui nous allons discuter de la prochaine version : Mehari 0.4 (nom de code: prostat lovers)

Pour ceux qui ont cliquÃ© pour la version 3.0, le changelog complet est disponible ci-dessous :

=> https://github.com/Psi-Prod/Mehari/releases/tag/0.3

N'hÃ©sitez pas Ã  faire vos remarques sur l'API de Mehari en commentaire.

## Dans l'assimilation parfaite

Pondre une API bien lissÃ©e est probablement ce que je prÃ©fÃ¨re faire en programmation (c'est notamment pour cette raison que j'aime OCaml). Pour rendre dÃ©pendant des utilisateurs de ma seule volontÃ© et percer dans le OCaml jeu, il vaut mieux Ã©crire des bibliothÃ¨ques aussi composables que possible. Si le meilleur des pythonista se mettait Ã  Ã©crire une bibliothÃ¨que OCaml, il produirait assurÃ©ment quelque chose de convenable mais pas trÃ¨s agrÃ©able Ã  utiliser. Et c'est bien normal car il ne connaÃ®t ni les idiomes du langage, ni son Ã©cosystÃ¨me.

Venons-en au point, je n'aime pas trop la faÃ§on dont les paramÃ¨tres de route sont gÃ©rÃ©s dans Mehari. Je m'explique :

```ocaml
let my_route =
  Mehari_lwt_unix.route "/echo/(.*)" ~regex:true (fun req ->
    Mehari.param req 1 |> Mehari.respond_text);
```

Ici, on dÃ©finit une route qui match tous les chemins qui commencent par `echo` et on renvoie le reste du chemin en utilisant `Mehari.param`.

Normalement, un truc a dÃ» vous piquer les yeux. Les regex sont Ã©crites en clair au lieu d'utiliser un DSL pur OCaml typesafe ! Et oui, il existe une super librairie â€“ sobrement nommÃ© `ocaml-re` (ðŸ—¿) â€“ qui permet d'Ã©crire des regex de maniÃ¨re encore plus incomprÃ©hensible :

```ocaml
Re.(seq [ str "foo="; group (rep1 any) ]) <=> "foo=(.+)
```

=> https://github.com/ocaml/ocaml-re

On va donc remplacer le paramÃ¨tre labellisÃ© boolÃ©en `regex` par quelque chose de plus puissant pour choisir si l'on souhaite :

* Fournir un `Re.t` ;
* Donner une route telle quelle sous forme de string ;
* Ã‰crire la regex en clair pour laisser les UNIX glob guys faire leur merdier.

Pour ce faire, deux options s'offrent Ã  nous :

* un GADT : c'est stylÃ© et Ã§a permet de faire varier le type de la route en fonction du paramÃ¨tre donnÃ© ;
* la simplicitÃ© : plusieurs fonctions sÃ©parÃ©es (`route_regex`, `route`â€¦).

Utiliser un GADT signifierait devoir prÃ©ciser un paramÃ¨tre labellisÃ© pour chaque type de route, mÃªme lorsqu'on veut gÃ©rer une route triviale comme `/articles`, ce qui n'est pas le cas actuellement dans Mehari. En effet, placer un constructeur d'un GADT en tant qu'argument par dÃ©faut conduit Ã  fixer le type de ce dernier et interdit logiquement d'utiliser des constructeurs d'un type diffÃ©rent :

```ocaml
type _ t = Int : int t | String : string t

let print (type a) ?(typ=Int) (x : a) = ...

let _ = print ~typ:String ""
                   ^^^^^^^^^
Error: This expression has type string t but an expression was expected of type
         int t
       Type string is not compatible with type int
```

> Si vous Ãªtes intÃ©ressÃ© par les GADT, j'en ai dÃ©jÃ  parlÃ© moins briÃ¨vement dans cet article :
=> /articles/gadt-mehari.gmi

### Que faire

Dans les deux cas prÃ©sentÃ©s, ce serait un breaking change. Mais qui utilise Mehari pour faire tourner son serveur Gemini, sÃ©rieusement ?

### Explication du design

Maintenant que le sujet est sur la table, je voulais m'expliquer concernant le choix de supporter directement des regex plutÃ´t que d'imposer notre propre systÃ¨me comme Dream le fait. D'un cÃ´tÃ©, Dream est plus lisible avec ses paramÃ¨tres nommÃ©s (`/foo/:bar`) mais d'un autre cÃ´tÃ©, les expressions rÃ©guliÃ¨res sont plus puissantes, bien que plus Â« austÃ¨res Â». Ã€ cela s'ajoute un argument non nÃ©gligeable : on n'avait pas envie de se faire chier.

## Le cas de Mehari.param

En bidouillant un peu, je me suis aperÃ§u que la sÃ©mantique de Mehari.param est assez dÃ©plorable. En effet, cette fonction lÃ¨ve la mÃªme exception si l'index est nÃ©gatif et si la paramÃ¨tre demandÃ© n'est pas prÃ©sent dans la route. Ci-dessous un extrait de la doc :

> Mehari.param req n retrieves the n-th path parameter of req.
> Raise Invalid_argument if n is not a positive integer
> Raise Invalid_argument if path does not contain any parameters in which case the program is buggy.

C'est donc sÃ©mantiquement impossible de distinguer une mauvaise utilisation de la fonction d'une erreur de programmation, mÃªme en matchant sur le string contenu dans le constructeur `Invalid_argument` !

```ocaml
try Mehari.param req 1 with Invalid_argument msg when String.starts_with ~prefix:"xxx" -> raise "JE SUIS COMPLÃˆTEMENT FOU ðŸ˜¹"
```

On va donc prochainement lever `Not_found` lorsque la route ne contiendra aucun paramÃ¨tre rÃ©cupÃ©rable. Enfin on va peut-Ãªtre ajouter une fonction Ã©quivalente qui renverra soit un `string option` en levant `Invalid_argument`, soit un `(string, [ `NotFound |Â `NegativeInteger]) result`. Je ne sais pas encore quelle signature est la mieux, dites-moi.

## Formater les esprits

AprÃ¨s m'avoir laissÃ© pour le moins perplexe pendant longtemps, j'ai dÃ©couvert que le module Format Ã©tait une fesserie. Je me suis ainsi convaincu qu'utiliser cette machinerie dans la fonction `Gemtext.to_string` pouvait potentiellement Ãªtre une bonne idÃ©e.

Je me suis heureusement rendu compte qu'utiliser Format a la fÃ¢cheuse tendance de ne plus faire de la fonction `Gemtext.of_string` une bijection rÃ©ciproque de `Gemtext.to_string` (car Format implÃ©mente le soft-wrap des lignes trop longues).

Pour me pardonner de mon impertinence, voici une recette pour obtenir un rendu Gemtext lisible qui rend hommage au beau, au juste et au vrai :

```ocaml
let pp_line ppf =
  let open Format in
  function
  | Text t -> pp_print_text ppf t
  | Link { url; name } ->
      fprintf ppf "@[<hov 2>â‡’ %s%a@]" url (pp_print_option (fun ppf ->
        fprintf ppf "@ %a" pp_print_text)) name
  | Preformat { alt; text } ->
      fprintf ppf "@[<v>%a@ %s@]" (pp_print_option pp_print_text) alt text
  | Heading (h, t) ->
    let hchar = match h with `H1 -> "â… " | `H2 -> "â…¡" | `H3 -> "â…¢" in
    fprintf ppf "@[<hov 2>%s %a@]" hchar pp_print_text t
  | ListItem t ->
    fprintf ppf "@[<hov 2>â€“ %a@]" pp_print_text t
  | Quote t ->
    let out_funs = Format.pp_get_formatter_out_functions ppf () in
    pp_set_formatter_out_functions ppf { out_funs with out_indent = (fun _ -> fprintf ppf "â–ˆ ")};
    fprintf ppf "@[<hov 0>â–ˆ %a@]" pp_print_text t;
    Format.pp_set_formatter_out_functions ppf out_funs

let pp = Format.pp_print_list ~pp_sep:Format.pp_force_newline pp_line

let gemtext =
  Mehari.Gemtext.[
    heading `H1 "Salut la compagnie";
    newline;
    link "https://heyplzlookat.me/" ~name:"Un super site";
    newline;
    heading `H2 "Passions";
    newline;
    text "Liste des passionsÂ :";
    list_item "le langage de prog OCaml"
    list_item "Marx";
    newline;
    quote "De trÃ¨s bonnes passions"
  ]

let () =
  Format.set_margin 20; (* Max 20 caractÃ¨res par ligne *)
  Format.printf "%a%!" pp gemtext
```

ImprÃ©gnez-vous maintenant d'esthÃ©tique, misÃ©rables misomuses :

```Sortie du programme ci-dessus
â…  Salut la
  compagnie

â‡’ https://heyplzlookat.me/
  Un super site

â…¡ Passions

Liste des
passions :
â€“ le langage de
  prog OCaml
â€“ Marx

â–ˆ De trÃ¨s bonnes
â–ˆ passions
```

## En vrac

### Static

Pour encore mieux intÃ©grer mehari-mirage, j'aimerais bien ajouter une fonction pour servir statiquement des fichiers depuis une expression de type `Mirage_kv.RO`.

### Gemtext

Il faudrait que l'on factorise le module Gemtext de Mehari dans un paquet tierce car on l'utilise Ã©galement dans Razzia, notre client Gemini secret non publiÃ© sur Opam en raison du manque de motivation pour Ã©crire sa documentation (mais qui reste malgrÃ© tout utilisable). De plus, cela nous permettrait de pouvoir tester le parser convenablement.

### Handler

En y repensant, je me disais qu'il faudrait pouvoir personnaliser le comportement en cas de not found avec un handler mÃªme si c'est techniquement rÃ©alisable avec ce hack :

```ocaml
Mehari_lwt_unix.router [
  ...;
  Mehari_lwt_unix.route "/(.*)" ~regex:true (fun _ ->
    Mehari.response not_found "not found !")
]
```
